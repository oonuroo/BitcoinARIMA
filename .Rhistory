filter(ds %in% test_data$ds) %>%
select(ds, yhat)
# âœ… Merge Predictions with Test Data for Evaluation
comparison <- merge(test_data, forecast_test, by = "ds", all.x = TRUE)
rmse <- sqrt(mean((comparison$y - comparison$yhat)^2, na.rm = TRUE))
mape <- mean(abs((comparison$y - comparison$yhat) / comparison$y), na.rm = TRUE) * 100
r2 <- cor(comparison$y, comparison$yhat, use = "complete.obs")^2
# âœ… Store Results
results <- rbind(results, data.frame(
Features = paste(features, collapse=", "),
ChangepointScale = scale,
RMSE = rmse,
MAPE = mape,
R2 = r2
))
}
}
View(prophet_model)
View(prophet_data)
colnames(prophet_data)
rm(prophet_data)
rm(prop.test())
rm(prophet_model)
rm(prophet_plot_components())
library(prophet)
library(ggplot2)
library(dplyr)
prophet_data <- selected_data %>%
select(YearMonth, Close, AdrActCnt, TxCnt, HashRate, TrendScore, AdrBalUSD10KCnt, log_Volume,
FeeMeanUSD, AdrBal1in1KCnt, AdrBalNtv10Cnt, AdrBalNtv10KCnt, diff_close, log_Close) %>%
rename(ds = YearMonth, y = Close)
prophet_data$ds <- as.Date(prophet_data$ds)
train_size <- floor(0.8 * nrow(prophet_data))
train_data <- prophet_data[1:train_size, ]
test_data <- prophet_data[(train_size + 1):nrow(prophet_data), ]
changepoint_values <- c(0.01, 0.05, 0.1, 0.2)  # Trend flexibility
seasonality_values <- c(1, 5, 10)  # Seasonality importance
feature_sets <- list(
c("AdrActCnt", "TxCnt", "HashRate"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close", "log_Close")
)
results <- data.frame()
# Step 5: Grid Search Loop
for (changepoint in changepoint_values) {
for (seasonality in seasonality_values) {
for (features in feature_sets) {
# Print Current Parameters
cat("\nTrying: Changepoint Prior Scale =", changepoint, "| Seasonality Prior Scale =", seasonality, "\n")
cat("Features:", paste(features, collapse=", "), "\n")
# Initialize Prophet model
m <- prophet(
changepoint.prior.scale = changepoint,
seasonality.prior.scale = seasonality
)
# Add Regressors
for (feature in features) {
m <- add_regressor(m, feature)
}
# Fit Model
m <- fit.prophet(m, train_data)
# Make Predictions
future <- make_future_dataframe(m, periods = nrow(test_data), freq = "month")
future <- future %>% left_join(prophet_data, by = "ds")  # Merge features
forecast <- predict(m, future)
# Extract Relevant Predictions
predictions <- forecast %>%
select(ds, yhat) %>%
filter(ds %in% test_data$ds)
# Calculate Evaluation Metrics
rmse <- sqrt(mean((test_data$y - predictions$yhat)^2, na.rm = TRUE))
mape <- mean(abs((test_data$y - predictions$yhat) / test_data$y), na.rm = TRUE) * 100
r2 <- cor(test_data$y, predictions$yhat, use = "complete.obs")^2
# Store Results
results <- rbind(results, data.frame(
ChangepointPriorScale = changepoint,
SeasonalityPriorScale = seasonality,
Features = paste(features, collapse=", "),
RMSE = rmse,
MAPE = mape,
R2 = r2
))
}
}
}
prophet_data <- selected_data %>%
select(YearMonth, Close, AdrActCnt, TxCnt, HashRate, TrendScore, AdrBalUSD10KCnt, log_Volume, FeeMeanUSD, AdrBal1in1KCnt, AdrBalNtv10Cnt, AdrBalNtv10KCnt, diff_close, log_Close) %>%
rename(ds = YearMonth, y = Close)
prophet_data$ds <- as.Date(prophet_data$ds)
train_size <- floor(0.8 * nrow(prophet_data))
train_data <- prophet_data[1:train_size, ]
test_data <- prophet_data[(train_size + 1):nrow(prophet_data), ]
param_grid <- expand.grid(
changepoint_prior_scale = c(0.001, 0.01, 0.1, 0.5, 1),
seasonality_prior_scale = c(0.01, 0.1, 1, 10),
stringsAsFactors = FALSE
)
results <- data.frame()
for (i in 1:nrow(param_grid)) {
# Extract parameters
cps <- param_grid$changepoint_prior_scale[i]
sps <- param_grid$seasonality_prior_scale[i]
cat("\nTrying Parameters: changepoint_prior_scale =", cps, "| seasonality_prior_scale =", sps, "\n")
# Train Prophet Model
m <- prophet(
changepoint.prior.scale = cps,
seasonality.prior.scale = sps,
yearly.seasonality = TRUE,
weekly.seasonality = FALSE,
daily.seasonality = FALSE
)
# Add regressors
regressors <- c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close", "log_Close")
for (reg in regressors) {
m <- add_regressor(m, reg)
}
# Fit Model
m <- fit.prophet(m, train_data)
# Make Predictions only for test period
future <- test_data %>%
select(ds, all_of(regressors))  # Ensure only test data is used for forecasting
forecast <- predict(m, future)
# Extract only the relevant columns
predictions <- forecast %>%
select(ds, yhat) %>%
rename(Predicted = yhat)
# Merge predictions with actual test values
prediction_results <- test_data %>%
select(ds, y) %>%
left_join(predictions, by = "ds")
# Calculate evaluation metrics
rmse_value <- rmse(prediction_results$y, prediction_results$Predicted)
mape_value <- mean(abs((prediction_results$y - prediction_results$Predicted) / prediction_results$y)) * 100
r2_value <- cor(prediction_results$y, prediction_results$Predicted, use = "complete.obs")^2
# Store results
results <- rbind(results, data.frame(
changepoint_prior_scale = cps,
seasonality_prior_scale = sps,
RMSE = rmse_value,
MAPE = mape_value,
R2 = r2_value
))
}
prophet_data <- selected_data %>%
select(YearMonth, Close, AdrActCnt, TxCnt, HashRate, TrendScore, AdrBalUSD10KCnt, log_Volume,
FeeMeanUSD, AdrBal1in1KCnt, AdrBalNtv10Cnt, AdrBalNtv10KCnt, diff_close, log_Close) %>%
rename(ds = YearMonth, y = Close)
prophet_data$ds <- as.Date(prophet_data$ds)
prophet_data <- prophet_data %>%
drop_na()
train_size <- floor(0.8 * nrow(prophet_data))
train_data <- prophet_data[1:train_size, ]
test_data <- prophet_data[(train_size + 1):nrow(prophet_data), ]
param_grid <- expand.grid(
changepoint_prior_scale = c(0.001, 0.01, 0.1, 0.5, 1),
seasonality_prior_scale = c(0.01, 0.1, 1, 10),
stringsAsFactors = FALSE
)
# Initialize results storage
results <- data.frame()
# Grid Search Loop
for (i in 1:nrow(param_grid)) {
# Extract parameters
cps <- param_grid$changepoint_prior_scale[i]
sps <- param_grid$seasonality_prior_scale[i]
cat("\nTrying Parameters: changepoint_prior_scale =", cps, "| seasonality_prior_scale =", sps, "\n")
# Train Prophet Model
m <- prophet(
changepoint.prior.scale = cps,
seasonality.prior.scale = sps,
yearly.seasonality = TRUE,
weekly.seasonality = FALSE,
daily.seasonality = FALSE
)
# Add regressors
regressors <- c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume",
"FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close", "log_Close")
for (reg in regressors) {
m <- add_regressor(m, reg)
}
# Fit Model
m <- fit.prophet(m, train_data)
# Make Predictions only for test period
future <- test_data %>%
select(ds, all_of(regressors))  # Ensure only test data is used for forecasting
forecast <- predict(m, future)
# Extract only the relevant columns
predictions <- forecast %>%
select(ds, yhat) %>%
rename(Predicted = yhat)
# Merge predictions with actual test values
prediction_results <- test_data %>%
select(ds, y) %>%
left_join(predictions, by = "ds")
# Calculate evaluation metrics
rmse_value <- rmse(prediction_results$y, prediction_results$Predicted)
mape_value <- mean(abs((prediction_results$y - prediction_results$Predicted) / prediction_results$y)) * 100
r2_value <- cor(prediction_results$y, prediction_results$Predicted, use = "complete.obs")^2
# Store results
results <- rbind(results, data.frame(
changepoint_prior_scale = cps,
seasonality_prior_scale = sps,
RMSE = rmse_value,
MAPE = mape_value,
R2 = r2_value
))
}
results <- results[order(results$RMSE), ]
print("Top 5 Best Models (Lowest RMSE):")
print(results[1:5, ])
# Select Best Model Parameters
best_params <- results[1, ]
cat("\nBest Parameters: changepoint_prior_scale =", best_params$changepoint_prior_scale, "| seasonality_prior_scale =", best_params$seasonality_prior_scale, "\n")
# Train Final Prophet Model with Best Parameters
final_model <- prophet(
changepoint.prior.scale = best_params$changepoint_prior_scale,
seasonality.prior.scale = best_params$seasonality_prior_scale,
yearly.seasonality = TRUE,
weekly.seasonality = FALSE,
daily.seasonality = FALSE
)
# Add regressors
for (reg in regressors) {
final_model <- add_regressor(final_model, reg)
}
# Fit final model on training data
final_model <- fit.prophet(final_model, train_data)
# Make final predictions
future_final <- test_data %>%
select(ds, all_of(regressors))
final_forecast <- predict(final_model, future_final)
# Extract final predictions
final_predictions <- final_forecast %>%
select(ds, yhat) %>%
rename(Predicted = yhat)
# Merge final predictions with actual test data
final_results <- test_data %>%
select(ds, y) %>%
left_join(final_predictions, by = "ds")
# Compute final metrics
final_rmse <- rmse(final_results$y, final_results$Predicted)
final_mape <- mean(abs((final_results$y - final_results$Predicted) / final_results$y)) * 100
final_r2 <- cor(final_results$y, final_results$Predicted, use = "complete.obs")^2
# Print final evaluation metrics
cat("\nðŸ† Final Prophet Model Metrics ðŸ†\n")
cat("RMSE:", final_rmse, "\n")
cat("MAPE:", final_mape, "\n")
cat("R^2:", final_r2, "\n")
# Prepare Data for Plotting
plot_data <- data.frame(
ds = test_data$ds,
Actual = test_data$y,
Predicted = final_results$Predicted
)
# Load historical data (Bitcoin monthly prices)
historical_data <- data.frame(
ds = train_data$ds,
Close = train_data$y
)
# ðŸ“ˆ **Plot Historical Data + Predictions**
ggplot() +
geom_line(data = historical_data, aes(x = ds, y = Close), color = "blue", size = 1, alpha = 0.7) +  # Historical Prices
geom_line(data = plot_data, aes(x = ds, y = Predicted), color = "red", linetype = "dashed", size = 1) +  # Predictions
geom_point(data = plot_data, aes(x = ds, y = Actual), color = "black", size = 2) +  # Actual Test Data
labs(
title = "Bitcoin Price Predictions vs. Historical Prices (Prophet)",
x = "Date",
y = "Bitcoin Price (USD)",
caption = "Blue: Historical Prices | Red Dashed: Prophet Predictions | Black Dots: Actual Test Prices"
) +
theme_minimal()
prophet_data <- selected_data %>%
select(YearMonth, Close, AdrActCnt, TxCnt, HashRate, TrendScore, AdrBalUSD10KCnt, log_Volume,
FeeMeanUSD, AdrBal1in1KCnt, AdrBalNtv10Cnt, AdrBalNtv10KCnt, diff_close, log_Close) %>%
rename(ds = YearMonth, y = Close)
View(prophet_data)
prophet_data$ds <- as.Date(prophet_data$ds)
# **Fix: Remove NA values before training**
prophet_data <- prophet_data %>%
drop_na()
View(predictor_vars)
train_size <- floor(0.8 * nrow(prophet_data))
train_data <- prophet_data[1:train_size, ]
test_data <- prophet_data[(train_size + 1):nrow(prophet_data), ]
param_grid <- expand.grid(
changepoint_prior_scale = c(0.01, 0.1, 0.5),
seasonality_prior_scale = c(0.01, 0.1, 1),
stringsAsFactors = FALSE
)
feature_sets <- list(
c("AdrActCnt", "TxCnt", "HashRate"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close", "log_Close")
)
results <- data.frame()
for (features in feature_sets) {
for (i in 1:nrow(param_grid)) {
params <- as.list(param_grid[i, ])
# Print Current Parameters
cat("\nTrying Parameters: changepoint_prior_scale =", params$changepoint_prior_scale,
"| seasonality_prior_scale =", params$seasonality_prior_scale, "\n")
cat("Features:", paste(features, collapse=", "), "\n")
# Prepare Train Data for Prophet
train_data_prophet <- train_data %>%
select(ds, y, all_of(features))
# Train Prophet Model
m <- prophet(
growth = "linear",
changepoint.prior.scale = params$changepoint_prior_scale,
seasonality.prior.scale = params$seasonality_prior_scale
)
# Add Regressors
for (feature in features) {
m <- add_regressor(m, feature)
}
# Fit Model
m <- fit.prophet(m, train_data_prophet)
# Predict on Test Data
future <- test_data %>%
select(ds, all_of(features))
predictions <- predict(m, future)
# Extract yhat (Predicted Values)
pred_values <- predictions$yhat[1:nrow(test_data)]
# Compute Metrics
rmse <- sqrt(mean((test_data$y - pred_values)^2, na.rm = TRUE))
mape <- mean(abs((test_data$y - pred_values) / test_data$y), na.rm = TRUE) * 100
r2 <- cor(test_data$y, pred_values, use = "complete.obs")^2
# Store Results
results <- rbind(results, data.frame(
Features = paste(features, collapse=", "),
ChangepointPriorScale = params$changepoint_prior_scale,
SeasonalityPriorScale = params$seasonality_prior_scale,
RMSE = rmse,
MAPE = mape,
R2 = r2
))
}
}
results <- results[order(results$RMSE), ]
print("Top 5 Best Models (Lowest RMSE):")
print(results[1:5, ])
best_model <- results[1, ]
best_features <- unlist(strsplit(best_model$Features, ", "))
best_params <- list(
changepoint_prior_scale = best_model$ChangepointPriorScale,
seasonality_prior_scale = best_model$SeasonalityPriorScale
)
# Train Final Model with Best Parameters
final_m <- prophet(
growth = "linear",
changepoint.prior.scale = best_params$changepoint_prior_scale,
seasonality.prior.scale = best_params$seasonality_prior_scale
)
# Add Best Regressors
for (feature in best_features) {
final_m <- add_regressor(final_m, feature)
}
final_m <- fit.prophet(final_m, train_data %>% select(ds, y, all_of(best_features)))
# Predict on Test Data
future <- test_data %>%
select(ds, all_of(best_features))
final_predictions <- predict(final_m, future)
# Extract yhat (Predicted Prices)
test_data$Predicted <- final_predictions$yhat[1:nrow(test_data)]
# ðŸ“ˆ **Plot Predictions vs. Historical Data**
ggplot() +
geom_line(data = bitcoin_monthly, aes(x = YearMonth, y = Close), color = "blue", size = 1) +  # Historical Prices
geom_line(data = test_data, aes(x = ds, y = Predicted), color = "red", linetype = "dashed", size = 1) +  # Predictions
labs(
title = "Bitcoin Price Predictions vs. Historical Prices (Prophet)",
x = "Date",
y = "Bitcoin Price (USD)",
caption = "Blue: Historical Prices | Red Dashed: Prophet Predictions"
) +
theme_minimal()
# Step 1: Prepare Data
prophet_data <- selected_data %>%
select(YearMonth, Close, AdrActCnt, TxCnt, HashRate, TrendScore, AdrBalUSD10KCnt, log_Volume,
FeeMeanUSD, AdrBal1in1KCnt, AdrBalNtv10Cnt, AdrBalNtv10KCnt, diff_close, log_Close) %>%
rename(ds = YearMonth, y = Close)  # Prophet requires 'ds' for date and 'y' for target variable
# Ensure correct date format
prophet_data$ds <- as.Date(prophet_data$ds)
# Remove NA values before training
prophet_data <- prophet_data %>%
drop_na()
# Step 2: Train-Test Split (80% Train, 20% Test)
train_size <- floor(0.8 * nrow(prophet_data))
train_data <- prophet_data[1:train_size, ]
test_data <- prophet_data[(train_size + 1):nrow(prophet_data), ]
# Step 3: Define Grid Search Parameters
param_grid <- expand.grid(
changepoint_prior_scale = c(0.001, 0.01, 0.1, 0.5, 1),
seasonality_prior_scale = c(0.01, 0.1, 1, 10),
stringsAsFactors = FALSE
)
# Feature Selection Sets
feature_sets <- list(
c("AdrActCnt", "TxCnt", "HashRate"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close"),
c("AdrActCnt", "TxCnt", "HashRate", "TrendScore", "AdrBalUSD10KCnt", "log_Volume", "FeeMeanUSD", "AdrBal1in1KCnt", "AdrBalNtv10Cnt", "AdrBalNtv10KCnt", "diff_close", "log_Close")
)
# Initialize results storage
results <- data.frame()
# Step 4: Grid Search Loop
for (features in feature_sets) {
for (i in 1:nrow(param_grid)) {
params <- as.list(param_grid[i, ])
# Print Current Parameters
cat("\nTrying Parameters: changepoint_prior_scale =", params$changepoint_prior_scale,
"| seasonality_prior_scale =", params$seasonality_prior_scale, "\n")
cat("Features:", paste(features, collapse=", "), "\n")
# Prepare Train Data for Prophet
train_data_prophet <- train_data %>%
select(ds, y, all_of(features))
# Train Prophet Model
m <- prophet(
growth = "linear",
changepoint.prior.scale = params$changepoint_prior_scale,
seasonality.prior.scale = params$seasonality_prior_scale
)
# Add Regressors
for (feature in features) {
m <- add_regressor(m, feature)
}
# Fit Model
m <- fit.prophet(m, train_data_prophet)
# Predict on Test Data
future <- test_data %>%
select(ds, all_of(features))
predictions <- predict(m, future)
# Extract yhat (Predicted Values)
pred_values <- predictions$yhat[1:nrow(test_data)]
# Compute Metrics
rmse <- sqrt(mean((test_data$y - pred_values)^2, na.rm = TRUE))
mape <- mean(abs((test_data$y - pred_values) / test_data$y), na.rm = TRUE) * 100
r2 <- cor(test_data$y, pred_values, use = "complete.obs")^2
# Store Results
results <- rbind(results, data.frame(
Features = paste(features, collapse=", "),
ChangepointPriorScale = params$changepoint_prior_scale,
SeasonalityPriorScale = params$seasonality_prior_scale,
RMSE = rmse,
MAPE = mape,
R2 = r2
))
}
}
# Sort results by RMSE (lower is better)
results <- results[order(results$RMSE), ]
print("Top 5 Best Models (Lowest RMSE):")
print(results[1:5, ])
# Select Best Model Parameters
best_model <- results[1, ]
best_features <- unlist(strsplit(best_model$Features, ", "))
best_params <- list(
changepoint_prior_scale = best_model$ChangepointPriorScale,
seasonality_prior_scale = best_model$SeasonalityPriorScale
)
# Train Final Model with Best Parameters
final_m <- prophet(
growth = "linear",
changepoint.prior.scale = best_params$changepoint_prior_scale,
seasonality.prior.scale = best_params$seasonality_prior_scale
)
# Add Best Regressors
for (feature in best_features) {
final_m <- add_regressor(final_m, feature)
}
# Fit Model
final_m <- fit.prophet(final_m, train_data %>% select(ds, y, all_of(best_features)))
# Predict on Test Data
future <- test_data %>%
select(ds, all_of(best_features))
final_predictions <- predict(final_m, future)
# Extract yhat (Predicted Prices)
test_data$Predicted <- final_predictions$yhat[1:nrow(test_data)]
# ðŸ“‰ **Adjust Historical Data to End at Prediction Date**
max_test_date <- max(test_data$ds)
historical_filtered <- bitcoin_monthly %>%
filter(YearMonth <= max_test_date)
# ðŸ“ˆ **Plot Predictions vs. Historical Data**
ggplot() +
geom_line(data = historical_filtered, aes(x = YearMonth, y = Close), color = "blue", size = 1) +  # Historical Prices
geom_line(data = test_data, aes(x = ds, y = Predicted), color = "red", linetype = "dashed", size = 1) +  # Predictions
labs(
title = "Bitcoin Price Predictions vs. Historical Prices (Prophet)",
x = "Date",
y = "Bitcoin Price (USD)",
caption = "Blue: Historical Prices | Red Dashed: Prophet Predictions"
) +
theme_minimal()
